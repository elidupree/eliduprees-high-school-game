<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>High School Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
/* CSS reset */
article,aside,figure,footer,header,hgroup,menu,nav,section { display:block; }
body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,
  legend,input,button,textarea,select,p,blockquote,th,td{margin:0;padding:0}
h1,h2,h3,h4,h5,h6 {font-size: 100%;font-weight: inherit;}
img {color: transparent; font-size: 0; border: 0; vertical-align: middle;
     -ms-interpolation-mode: bicubic;}

html {
  font-size: 2em;
}

#player_viewport {
  max-width: 30em;
  margin: 1em auto;
}
a.choice {
  display: block;
  margin: 1em 1em;
}
.description-preceding-choice {
  margin: 1em 0;
}
.status-area-wrapper {
  float: right;
  position: relative;
}
.status-area {
  padding: 1em;
  border: 2px solid green;
  font-size: 0.8em;
  width: 19.3em;
  background-color: #fff;
  position: relative;
}
.old-status-area {
  position: absolute;
  top: 0;
  left: 0;
}
.status-bars {
  margin-bottom: 0.8em;
}
.status-bar {
  font-family: monospace;
}
.trait-list {
  margin-top: 1em;
}
.example-symbol {
  opacity: 0.3;
}
</style>
</head>
<body>
<div id="player_viewport">
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script>
(function () {
"use strict";

function assert(x) {
  if(!x) {
    throw 'error!';
  }
}

window.Eli = {};
Eli.traits = {
  daydream: {
    description: "You can daydream whenever you want.",
    choice: {
      name: "daydream",
      tags: ['daydream'],
      do: function(dilemma) {
        dilemma.actor.messages.push("You daydream about popsicles.");
      }
    }
  },
  video_gaming: function() { return {
    description: "When you're at home, you can play video games.",
    choice: function(dilemma) {
      if(dilemma.actor.location === 'home') { return {
        name: "play video games",
        tags: ['video_games'],
        do: function(dilemma) {
          var score = (Math.round(Math.pow(1.03, _.random(2, 1000))) + 2);
          dilemma.actor.messages.push("You score " + score + " points!");
        }
      }; }
    }
  };},
  video_gaming_affects_your_status: function(status_id_to_buff, amount) { return {
    description: ("When you play video games, you feel more " + status_id_to_buff
       + ". " + Eli.status_buff_symbols(status_id_to_buff, amount)),
    effect: function(dilemma, choice) {
      if(_.contains(choice.tags, 'video_games')) {
        increment_status(dilemma.actor, status_id_to_buff, amount);
        dilemma.actor.messages.push("You feel more " + status_id_to_buff + "! " +
          Eli.status_buff_symbols(status_id_to_buff, amount));
      }
    }
  };},
  go_to_school: {
    description: "You can go to school [during school hours?].",
    choice: function(dilemma) {
      if(dilemma.actor.location !== 'school') { return {
        name: "go to school",
        tags: ['go', 'go_to_school'],
        do: function(dilemma) {
          dilemma.actor.location = 'school';
          dilemma.actor.messages.push("You take the bus to school.");
        }
      }; }
    }
  },
  go_to_home: {
    description: "You can go home.",
    choice: function(dilemma) {
      if(dilemma.actor.location !== 'home') { return {
        name: "go home",
        tags: ['go', 'go_home'],
        do: function(dilemma) {
          dilemma.actor.location = 'home';
        dilemma.actor.messages.push("You walk home.");
        }
      }; }
    }
  },
  swear: {
    description: "You can swear whenever you want.",
    choice: {
      instant: true,
      name: "swear",
      tags: ['swear'],
      do: function(dilemma) {
        dilemma.actor.messages.push("Fuck!");
      }
    }
  },
  dud: null //just so we can put a comma after all real ones consistently
};

function look_up_trait(name_and_args) {
  var name;
  var args;
  if (_.isString(name_and_args)) {
    name = name_and_args;
    args = [];
  } else {
    name = name_and_args[0];
    args = _.rest(name_and_args);
  }
  var t = Eli.traits[name];
  if (_.isFunction(t)) {
    t = t.apply(null, args);
  }
  return t;
}
// only the choices that are applicable right now
function get_trait_choices(dilemma, trait) {
  if (!trait.choice) {
    return [];
  }
  var c = trait.choice;
  if (_.isFunction(c)) {
    c = c(dilemma);
  }
  if (!c) {
    c = [];
  }
  if (!_.isArray(c)) {
    c = [c];
  }
  c = _.filter(c, function(choice) {
    return !dilemma.already_tried[choice.name];
  });
  return c;
}

function get_character_choices(dilemma) {
  return _.flatten(_.map(dilemma.actor.traits, function(t) {
    return get_trait_choices(dilemma, look_up_trait(t));
  }), true);
}

Eli.game_state = {
  todo: [], // a stack that you push/pop on the end
  phase: 0,
  characters: [] // order doesn't matter?
};
var game_state = Eli.game_state;

var Bob = {
  traits: [
    'daydream',
    'video_gaming',
    ['video_gaming_affects_your_status', 'confident'],
    'swear',
    'go_to_school',
    'go_to_home'
  ],
  location: 'school',
  old_messages: [],
  messages: [],
  status: {
    confidence: 2,
    excitement: -1
  }
};
game_state.characters.push(Bob);


// Make sure save games can't run scripts or stuff.
// The result of this function will be passed to
// innerHTML= or more specifically,
// $(...).html(Eli.check_message_html(....))
Eli.check_message_html = function(message) {
  if(!/^([^<>&]*(&lt;|&gt;|&amp;|&quot;|<span( style="((color|background-color): [a-zA-Z0-9#%() ,]*(;|(?= *")) *)*")?>|<\/span>))*[^<>&]*$/.test(message)) {
    throw "Uncheckable message: " + message;
  }
  return message;
}

Eli.symbol = function(text_content, text_color, background_color) {
  return $('<span/>').css({
      "color": text_color,
      "background-color": background_color
    }).text(text_content).prop('outerHTML');
};
Eli.status_buff_symbols = function(status_id_to_buff, amount) {
  if(amount === undefined) { amount = 1; }
  return Eli.status_types[status_id_to_buff].symbol.repeat(amount);
}
Eli.status_max = 3;
Eli.neutral_status_symbol = Eli.symbol('0', '#bbb', '#555');
Eli.general_status_types_list = [{
    id: 'confidence',
    positive: {
        name: "confident",
        symbol: Eli.symbol('+', '#fff', '#00f')
    },
    negative: {
        name: "crushed",
        symbol: Eli.symbol('-', '#00f', '#000')
    }
  },
  {
    id: 'excitement',
    positive: {
      name: "excited",
      symbol: Eli.symbol('!', '#ff0', '#f00')
    },
    negative: {
      name: "calm",
      symbol: Eli.symbol('~', '#00f', '#ccf')
    }
  }
];
Eli.general_status_types = {};
Eli.status_types = {};
Eli.max_status_name_length = 0;
for (var i = 0; i < Eli.general_status_types_list.length; ++i) {
  var status = Eli.general_status_types_list[i];
  Eli.general_status_types[status.id] = status;
  Eli.status_types[status.positive.name] = status.positive;
  Eli.status_types[status.negative.name] = status.negative;
  status.positive.opposite = status.negative;
  status.negative.opposite = status.positive;
  status.positive.general = status;
  status.negative.general = status;
  status.positive.sign = 1;
  status.negative.sign = -1;
  Eli.max_status_name_length = Math.max(Eli.max_status_name_length,
    status.positive.name.length, status.negative.name.length);
}

function get_status(character, status_name) {
  var status_type = Eli.status_types[status_name];
  return character.status[status_type.general.id] * status_type.sign;
}
function set_status(character, status_name, value) {
  assert(Math.round(value) === value && Math.abs(value) <= Eli.status_max);
  var status_type = Eli.status_types[status_name];
  character.status[status_type.general.id] = value * status_type.sign;
  assert(get_status(character, status_name) === value);
}
function increment_status(character, status_name, amount) {
  if(amount === undefined) { amount = 1; }
  assert(Math.round(amount) === amount && amount > 0);
  var old_value = get_status(character, status_name);
  var new_value = Math.min(old_value + amount, Eli.status_max);
  set_status(character, status_name, new_value);
  return new_value - old_value;
}

// assumes monospace
Eli.pad_left = function(html_text, count, pad_character) {
  var text_length = $('<div/>').html(html_text).text().length;
  if (pad_character === undefined) { pad_character = '&nbsp;'; }
  return (pad_character.repeat(count - text_length) + html_text);
};
Eli.pad_right = function(html_text, count, pad_character) {
  var text_length = $('<div/>').html(html_text).text().length;
  if (pad_character === undefined) { pad_character = '&nbsp;'; }
  return (html_text + pad_character.repeat(count - text_length));
};
function example_symbol(symbol) {
  return $('<span/>').addClass('example-symbol').html(symbol).prop('outerHTML');
}
Eli.status_bar = function(character, general_status_type) {
  var negative_points = Math.max(0, -character.status[general_status_type.id]);
  var positive_points = Math.max(0, character.status[general_status_type.id]);
  return $('<span/>').addClass('status-bar').html(
    Eli.pad_left(general_status_type.negative.name, Eli.max_status_name_length+2) + ' ' + example_symbol(general_status_type.negative.symbol) +
    ' [' + Eli.pad_left(general_status_type.negative.symbol.repeat(negative_points), Eli.status_max) +
    Eli.neutral_status_symbol +
    Eli.pad_right(general_status_type.positive.symbol.repeat(positive_points), Eli.status_max) + '] ' +
    example_symbol(general_status_type.positive.symbol) + ' ' + Eli.pad_right(general_status_type.positive.name, Eli.max_status_name_length+2)
    );
};
Eli.status_area = function(character) {
  var $status_bars = $('<div/>').addClass('status-bars');
  for (var i = 0; i < Eli.general_status_types_list.length; ++i) {
    var general_status_type = Eli.general_status_types_list[i];
    if (_.has(character.status, general_status_type.id)) {
      $status_bars.append($('<div/>').append(Eli.status_bar(character, general_status_type)));
    }
  }
  var $traits = $('<div/>').addClass('trait-list');
  _.each(_.map(character.traits, look_up_trait), function(trait) {
    $traits.append($('<p/>').html(Eli.check_message_html(trait.description)));
  });
  return $('<div/>').addClass('status-area').append(
    $status_bars,
    $('<p/>').text("You are at " + character.location + '.'),
    $traits
  );
};

function possibly_go_to_the_next_phase() {
  if(game_state.todo.length === 0) {
    game_state.phase += 1;
    _.each(_.shuffle(game_state.characters), function(c) {
      game_state.todo.push({ actor: c, already_tried: {}});
    });
  }
}

function current_dilemma() {
  return _.last(game_state.todo);
}

function dilemma_requires_player_input(dilemma) {
  return true;
}

// returns true if succeeded
function try_to_make_choice(dilemma, choice) {
  // check patterns to see if choice works [for now, always]
  // apply any effects that were triggered by simply making the choice (before do()?)
  var succeeded = true;
  dilemma.already_tried[choice.name] = true;
  if (succeeded) {
    if(!choice.instant) {
      var d = game_state.todo.pop(); assert(d == dilemma);
    }
    choice.do(dilemma);
    _.each(dilemma.actor.traits, function(t) {
      var trait = look_up_trait(t);
      if(trait.effect) {
        trait.effect(dilemma, choice);
      }
    });
  }
  return succeeded;
}

function make_choice_automatically(dilemma) {
  // check patterns to see if choice works
  // apply any effects that were triggered by simply making the choice (before do()?)
  if (!try_to_make_choice(dilemma, _.sample(get_character_choices(dilemma)))) {
    game_state.todo.push(dilemma);
  }
}

function get_to_the_next_point_where_a_player_character_has_a_choice() {
  while(true) {
    possibly_go_to_the_next_phase();
    assert(game_state.todo.length > 0);
    if(dilemma_requires_player_input(current_dilemma())) {
      break;
    } else {
      make_choice_automatically(current_dilemma());
    }
  }
  var $vp = $('#player_viewport');
  var $old_status_area = $('#player_viewport .status-area:not(.old-status-area)').detach();
  $vp.empty();
  var dilemma = current_dilemma();
  $old_status_area.addClass('old-status-area');
  var $new_status_area = Eli.status_area(dilemma.actor);
  var $status_area_wrapper = $('<div/>').addClass('status-area-wrapper').append($old_status_area, $new_status_area);
  $new_status_area.css({opacity: 0}).animate({opacity: 1}, function() { $old_status_area.remove(); });
  $vp.append($status_area_wrapper);
  var $main = $('<div/>').css({opacity: 0}).animate({opacity: 1});
  _.each(dilemma.actor.messages, function(message) {
    $main.append($('<p/>').html(Eli.check_message_html(message)));
  });
  $main.append($('<p/>').addClass('description-preceding-choice').text("You have a choice!!!!!"));
  _.each(get_character_choices(dilemma), function(choice) {
    $main.append($('<a/>').addClass('choice').attr('href', '#javascript').text(choice.name).on('click', function(e) {
      e.stopPropagation();
      e.preventDefault();
      // should this happen always? or just on success
      Array.prototype.push.apply(dilemma.actor.old_messages, dilemma.actor.messages);
      dilemma.actor.messages = [];
      var succeeded = try_to_make_choice(dilemma, choice);
      get_to_the_next_point_where_a_player_character_has_a_choice();
    }));
  });
  $vp.append($main);
}

get_to_the_next_point_where_a_player_character_has_a_choice();

})();
</script>
</body>
</html>